[
    {
        "description": "[Coverage] Lazy pattern, greedy match - backslash with '*' modifier. The next token does not include the map characters of the current token and has '+' modifier.",
        "batch_test": [
            {
                "description": "Min size",
                "pattern": "\\w*\\s+",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Min size. Capture all.",
                "pattern": "(\\w*\\s+)",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Min size, with group",
                "pattern": "(\\w*)\\s+",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Other size",
                "pattern": "\\w*\\s+",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Other size. With group",
                "pattern": "(\\w*)\\s+",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Other size. With group",
                "__know_issue": "Consecutive capture groups don't support. should match 'wazuh ' but it doesn't. But (\\w+)\\d*(\\s+) works",
                "ignore_result": true,
                "pattern": "(\\w*)(\\s+)",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive, and opcional",
                "pattern": "(\\w*)\\d*(\\s+)",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive, and opcional",
                "pattern": "(\\w*)\\d*(\\s+)",
                "log": "wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive",
                "pattern": "(\\w*)\\d+(\\s+)",
                "log": "wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive, and opcional",
                "pattern": "(\\w*)\\d*(\\s*)",
                "__know_issue": "Err retval.",
                "ignore_result": true,
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive, and opcional",
                "pattern": "(\\w*)\\d*(\\s*)",
                "__know_issue": "Err retval.",
                "ignore_result": true,
                "log": "wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive",
                "pattern": "(\\w*)\\d+(\\s*)",
                "__know_issue": "Err retval.",
                "ignore_result": true,
                "log": "wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "With literal at the end.",
                "pattern": "\\w*\\s+1",
                "log": "wazuh 1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "description": "With literal at the end, 1 character + capture group.",
                "pattern": "(\\w*)\\s+1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "With literal at the end, 1 character + capture all.",
                "pattern": "(\\w*\\s+)1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "With literal at the end, 1 character + capture",
                "pattern": " (\\w*)\\s+1",
                "log": " wazuh 1",
                "end_match": "1",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Min size. Match all. 1 character (With flags).",
                "pattern": "^\\w*\\s+$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all (With flags).",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "pattern": "^\\w*\\s+$",
                "log": "wazuh  ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all. 1 character + capture group. (With flags).",
                "pattern": "^(\\w*)\\s+$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match all. 1 character + capture group. (With flags).",
                "pattern": "^(\\w*)\\s+$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token with blackslash.  ok_here == -1. Match all. 1 character + capture all. (With flags).",
                "pattern": "^(\\w*\\s+)$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Dont match.",
                "pattern": "^\\w*\\s+$",
                "log": "wazuh -",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Dont match.",
                "pattern": "^(\\w*\\s+)$",
                "log": "wazuh -",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Coverage] Lazy pattern, greedy match - backslash with '*' modifier. The next token does include the map characters of the current token and has '*' modifier.",
        "batch_test": [
            {
                "description": "Min size",
                "pattern": "\\w*\\s*",
                "log": "w",
                "end_match": "w",
                "captured_groups": []
            },
            {
                "description": "Min size + opt.",
                "pattern": "\\w*\\s*",
                "__know_issue": "Err retval.",
                "ignore_result": true,
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Min size. Capture all.",
                "pattern": "(\\w*\\s*)",
                "__know_issue": "The group: 'w' cannot be found",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Min size. Capture all.",
                "pattern": "(\\w*\\s*)",
                "log": "wazuh",
                "end_match": "h",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Min size + opt. Capture all.",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "pattern": "(\\w*\\s*)",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Min size, with group",
                "pattern": "(\\w*)\\s*",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Min size + opt, with group",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "pattern": "(\\w*)\\s*",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Other size",
                "pattern": "\\w*\\s*",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Other size. With group",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "pattern": "(\\w*\\s*)",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh "
                ]
            },
            {
                "description": "Other size. With group",
                "__know_issue": "Consecutive capture groups don't support. should match 'wazuh ' but it doesn't. But (\\w+)\\d*(\\s+) works",
                "ignore_result": true,
                "pattern": "(\\w*)(\\s*)",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive, and opcional",
                "pattern": "(\\w*)\\d+(\\s*)",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "wazuh ",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "2 groups no consecutive, and opcional",
                "pattern": "(\\w*)\\d+(\\s*)",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive",
                "pattern": "(\\w*)\\d*(\\s*)",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "With literal at the end.",
                "pattern": "\\w*\\s*1",
                "log": "wazuh 1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "description": "With literal at the end, 1 character + capture group.",
                "pattern": "(\\w*)\\s*1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "With literal at the end, 1 character + capture all.",
                "pattern": "(\\w*\\s*)1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "With literal at the end, 1 character + capture",
                "pattern": " (\\w*)\\s*1",
                "log": " wazuh 1",
                "end_match": "1",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Min size. Match all. 1 character (With flags).",
                "pattern": "^\\w*\\s*$",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all (With flags).",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "pattern": "^\\w*\\s*$",
                "log": "wazuh  ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all. 1 character + capture group. (With flags).",
                "pattern": "^(\\w*)\\s*$",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match all. 1 character + capture group. (With flags).",
                "pattern": "^(\\w*)\\s*$",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token with blackslash.  ok_here == -1. Match all. 1 character + capture all. (With flags).",
                "pattern": "^(\\w*\\s*)$",
                "ignore_result": true,
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Dont match.",
                "pattern": "^\\w*\\s*$",
                "log": "wazuh -",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Dont match.",
                "pattern": "^(\\w*\\s*)$",
                "log": "wazuh -",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Coverage] Lazy pattern, greedy match - backslash with '+' modifier. The next token does not include the map characters of the current token and has '+' modifier.",
        "batch_test": [
            {
                "description": "Min size",
                "pattern": "\\w+\\s+",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Min size. Capture all.",
                "pattern": "(\\w+\\s+)",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Min size, with group",
                "pattern": "(\\w+)\\s+",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Other size",
                "pattern": "\\w+\\s+",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Other size. With group",
                "pattern": "(\\w+)\\s+",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Other size. With group",
                "__know_issue": "Consecutive capture groups don't support. should match 'wazuh ' but it doesn't. But (\\w+)\\d*(\\s+) works",
                "ignore_result": true,
                "pattern": "(\\w+)(\\s+)",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive, and opcional",
                "pattern": "(\\w+)\\d*(\\s+)",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive, and opcional",
                "pattern": "(\\w+)\\d*(\\s+)",
                "log": "wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive",
                "pattern": "(\\w+)\\d+(\\s+)",
                "log": "wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "With literal at the end.",
                "pattern": "\\w+\\s+1",
                "log": "wazuh 1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "description": "With literal at the end, 1 character + capture group.",
                "pattern": "(\\w+)\\s+1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "With literal at the end, 1 character + capture all.",
                "pattern": "(\\w+\\s+)1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "With literal at the end, 1 character + capture",
                "pattern": " (\\w+)\\s+1",
                "log": " wazuh 1",
                "end_match": "1",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Min size. Match all. 1 character (With flags).",
                "pattern": "^\\w+\\s+$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all (With flags).",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "pattern": "^\\w+\\s+$",
                "log": "wazuh  ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all. 1 character + capture group. (With flags).",
                "pattern": "^(\\w+)\\s+$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match all. 1 character + capture group. (With flags).",
                "pattern": "^(\\w+)\\s+$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token with blackslash.  ok_here == -1. Match all. 1 character + capture all. (With flags).",
                "pattern": "^(\\w+\\s+)$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Dont match.",
                "pattern": "^\\w+\\s+$",
                "log": "wazuh -",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Dont match.",
                "pattern": "^(\\w+\\s+)$",
                "log": "wazuh -",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Coverage] Lazy pattern, greedy match - backslash with '+' modifier. The next token does include the map characters of the current token and has '*' modifier.",
        "batch_test": [
            {
                "description": "Min size",
                "pattern": "\\w+\\s*",
                "log": "w",
                "end_match": "w",
                "captured_groups": []
            },
            {
                "description": "Min size + opt.",
                "pattern": "\\w+\\s*",
                "__know_issue": "Err retval.",
                "ignore_result": true,
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Min size. Capture all.",
                "pattern": "(\\w+\\s*)",
                "__know_issue": "The group: 'w' cannot be found",
                "ignore_result": true,
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Min size. Capture all.",
                "pattern": "(\\w+\\s*)",
                "__know_issue": "The group: 'wazuh' cannot be found",
                "ignore_result": true,
                "debug": false,
                "log": "wazuh",
                "end_match": "h",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Min size + opt. Capture all.",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "pattern": "(\\w+\\s*)",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Min size, with group",
                "pattern": "(\\w+)\\s*",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Min size + opt, with group",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "pattern": "(\\w+)\\s*",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Other size",
                "pattern": "\\w+\\s*",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Other size. With group",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "pattern": "(\\w+\\s*)",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh "
                ]
            },
            {
                "description": "Other size. With group",
                "__know_issue": "Consecutive capture groups don't support. should match 'wazuh ' but it doesn't. But (\\w+)\\d*(\\s+) works",
                "ignore_result": true,
                "pattern": "(\\w+)(\\s*)",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive, and opcional",
                "pattern": "(\\w+)\\d+(\\s*)",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "wazuh ",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "2 groups no consecutive, and opcional",
                "pattern": "(\\w+)\\d+(\\s*)",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "2 groups no consecutive",
                "pattern": "(\\w+)\\d*(\\s*)",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "debug": false,
                "log": "wazuh123 ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh",
                    " "
                ]
            },
            {
                "description": "With literal at the end.",
                "pattern": "\\w+\\s*1",
                "log": "wazuh 1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "description": "With literal at the end, 1 character + capture group.",
                "pattern": "(\\w+)\\s*1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "With literal at the end, 1 character + capture all.",
                "pattern": "(\\w+\\s*)1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "With literal at the end, 1 character + capture",
                "pattern": " (\\w+)\\s*1",
                "log": " wazuh 1",
                "end_match": "1",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Min size. Match all. 1 character (With flags).",
                "pattern": "^\\w+\\s*$",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all (With flags).",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "pattern": "^\\w+\\s*$",
                "log": "wazuh  ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Match all. 1 character + capture group. (With flags).",
                "pattern": "^(\\w+)\\s*$",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Match all. 1 character + capture group. (With flags).",
                "pattern": "^(\\w+)\\s*$",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token with blackslash.  ok_here == -1. Match all. 1 character + capture all. (With flags).",
                "pattern": "^(\\w+\\s*)$",
                "ignore_result": true,
                "__know_issue": "Err retval.",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Dont match.",
                "pattern": "^\\w+\\s*$",
                "log": "wazuh -",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Dont match.",
                "pattern": "^(\\w+\\s*)$",
                "log": "wazuh -",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Coverage] Lazy pattern, greedy match - backslash with '*' modifier. st_error, error handling, parcial match and rewind.",
        "batch_test": [
            {
                "description": "Save 6 token position, and restore the first.",
                "pattern": "\\w*_1 \\w*_2 \\w*_3 \\w*_4 \\w*_5 \\w*_6",
                "log": "wa_11 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the second.",
                "pattern": "\\w*_1 \\w*_2 \\w*_3 \\w*_4 \\w*_5 \\w*_6",
                "log": "wa_1 wa_22 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the third.",
                "pattern": "\\w*_1 \\w*_2 \\w*_3 \\w*_4 \\w*_5 \\w*_6",
                "log": "wa_1 wa_2 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the fourth.",
                "pattern": "\\w*_1 \\w*_2 \\w*_3 \\w*_4 \\w*_5 \\w*_6",
                "log": "wa_1 wa_2 wa_3 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the fifth.",
                "pattern": "\\w*_1 \\w*_2 \\w*_3 \\w*_4 \\w*_5 \\w*_6",
                "log": "wa_1 wa_2 wa_3 wa_4 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the sixth.",
                "pattern": "\\w*_1 \\w*_2 \\w*_3 \\w*_4 \\w*_5 \\w*_6",
                "log": "wa_1 wa_2 wa_3 wa_4 wa_5 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the first. But the first should match with the next character.",
                "pattern": "\\w*1 \\w*2 \\w*3 \\w*4 \\w*5 \\w*6",
                "log": "z1x1 x2 x3 x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the second. But the second should match with the next character.",
                "pattern": "\\w*1 \\w*2 \\w*3 \\w*4 \\w*5 \\w*6",
                "log": "z1 x2x2 x3 x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the third. But the third should match with the next character.",
                "pattern": "\\w*1 \\w*2 \\w*3 \\w*4 \\w*5 \\w*6",
                "log": "z1 x2x2 x3 x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the fourth. But the fourth should match with the next character.",
                "pattern": "\\w*1 \\w*2 \\w*3 \\w*4 \\w*5 \\w*6",
                "log": "z1 x2 x3 x4x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the fifth. But the fifth should match with the next character.",
                "pattern": "\\w*1 \\w*2 \\w*3 \\w*4 \\w*5 \\w*6",
                "__knowIssue": "#XXXX The stacktrace has a static size",
                "ignore_result": true,
                "log": "z1 x2 x3 x4 x5x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the sixth. But the sixth should match with the next character.",
                "pattern": "\\w*1 \\w*2 \\w*3 \\w*4 \\w*5 \\w*6",
                "log": "z1 x2 x3 x4 x5 x6x6",
                "__knowIssue": "#XXXX The stacktrace has a static size",
                "ignore_result": true,
                "end_match": "6",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Coverage] Lazy pattern, greedy match - backslash with '*' modifier. The next token does include the map characters of the current token and has no modifier.",
        "batch_test": [
            {
                "description": "0 size: `\\d*` match 0-0",
                "pattern": "\\d*\\w",
                "log": "5",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "0 size: `\\d*` match 0-0. With group",
                "pattern": "(\\d*)\\w",
                "log": "5",
                "end_match": "5",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "\\w matches with '1' character",
                "pattern": "\\d*\\w",
                "log": "12",
                "end_match": "12",
                "captured_groups": []
            },
            {
                "description": "\\w matches with '1' character",
                "pattern": "(\\d*)\\w",
                "log": "12",
                "end_match": "12",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Min size: Minimum match with capture group",
                "pattern": "\\d*(\\w)",
                "log": "12",
                "end_match": "12",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern",
                "pattern": "\\d*\\w",
                "log": "12345",
                "end_match": "12345",
                "captured_groups": []
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern, only capture the first character",
                "pattern": "(\\d*)\\w",
                "log": "12345",
                "end_match": "12345",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern",
                "pattern": "\\d*(\\w)",
                "log": "12345",
                "end_match": "12345",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Min size: No match, no items in the log to consume (With flags).",
                "pattern": "^\\d*\\d",
                "log": "5",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "Min size: No match, no items in the log to consume (With flags).",
                "pattern": "^(\\d*)\\d",
                "log": "5",
                "end_match": "5",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Min size: Minimum match with capture group (With flags).",
                "pattern": "^(\\d*)\\w$",
                "log": "12",
                "end_match": "2",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Min size: Minimum match with capture group (With flags).",
                "pattern": "^\\d*(\\w)$",
                "log": "12",
                "end_match": "2",
                "captured_groups": [
                    "2"
                ]
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern (With flags).",
                "pattern": "^\\d*\\w$",
                "log": "12345",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern, capture the first 4 character, because the $ flag.",
                "pattern": "^(\\d*)\\w$",
                "log": "12345",
                "end_match": "5",
                "captured_groups": [
                    "1234"
                ]
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern (With flags).",
                "pattern": "^\\d*(\\w)$",
                "log": "12345",
                "end_match": "5",
                "captured_groups": [
                    "5"
                ]
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern (With flags).",
                "pattern": "^\\d*(\\w)$",
                "log": "12345&&&&&&&",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Coverage] Lazy pattern, greedy match - backslash with '*' modifier. The next token does not include the map characters of the current token and has no modifier.",
        "batch_test": [
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. 1 character",
                "pattern": "\\w*\\s",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all",
                "pattern": "\\w*\\s",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. 1 character * capture group.",
                "pattern": "(\\w*)\\s",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match 0-0. 1 character * capture group.",
                "pattern": "(\\w*)\\s",
                "log": " ",
                "end_match": " ",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Next token with blackslash.  ok_here == -1. Match all. 1 character * capture all.",
                "pattern": "(\\w*\\s)",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Next token with blackslash.  ok_here == -1. Match all. 1 character * capture all.",
                "pattern": "(\\w*\\s)",
                "log": " ",
                "end_match": " ",
                "captured_groups": [
                    " "
                ]
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. Parcial capture group case.",
                "pattern": "(\\w*)\\s",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. 1 character",
                "pattern": "\\w* ",
                "log": " ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. 1 character",
                "pattern": "\\w* ",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all",
                "pattern": "\\w* ",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. 1 character * capture group.",
                "pattern": "(\\w*) ",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. 1 character * capture all.",
                "pattern": "(\\w* )",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. Parcial capture group case.",
                "pattern": "(\\w*) ",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all",
                "pattern": "\\w*\\s1",
                "log": "wazuh 1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. 1 character * capture group.",
                "pattern": "(\\w*)\\s1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. 1 character * capture all.",
                "pattern": "(\\w*\\s)1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Next token with blackslash. ok_here ==  -1. Match all. Parcial capture group case.",
                "pattern": "(\\w*)\\s1",
                "log": "wazuh 1",
                "end_match": "1",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match. 1 character",
                "pattern": "\\w*\\s1",
                "log": "w 123",
                "end_match": "123",
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match",
                "pattern": "\\w* 1",
                "log": "wazuh 123",
                "end_match": "123",
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match. 1 character * capture group.",
                "pattern": "(\\w*) 1",
                "log": "w 123",
                "end_match": "123",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match. 1 character * capture all.",
                "pattern": "(\\w* )1",
                "log": "w 123",
                "end_match": "123",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match. Parcial capture group case.",
                "pattern": "(\\w*) 1",
                "log": "wazuh 123",
                "end_match": "123",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. 1 character (With flags).",
                "pattern": "^\\w*\\s$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all (With flags).",
                "pattern": "^\\w*\\s$",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. 1 character * capture group. (With flags).",
                "pattern": "^(\\w*)\\s$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token with blackslash.  ok_here == -1. Match all. 1 character * capture all. (With flags).",
                "pattern": "^(\\w*\\s)$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. Parcial capture group case. (With flags).",
                "pattern": "^(\\w*)\\s$",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. 1 character (With flags).",
                "pattern": "^\\w* $",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all (With flags).",
                "pattern": "^\\w* $",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. 1 character * capture group (With flags).",
                "pattern": "^(\\w*) $",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. 1 character * capture all (With flags).",
                "pattern": "^(\\w* )$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. Parcial capture group case (With flags).",
                "pattern": "^(\\w*) $",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. Ends pattern (With flags) before log.",
                "pattern": "^\\w* $",
                "log": "wazuh -",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. Ends pattern (With flags and capture all) before log.",
                "pattern": "^(\\w* )$",
                "log": "wazuh -",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Coverage] Regex, only backslash with '*' modifier.",
        "batch_test": [
            {
                "description": "Without capture group, match all",
                "ignore_result": true,
                "pattern": "\\w*",
                "log": "wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "Without capture group, match 0-0",
                "__know_issue": "Return one byte before log starts ",
                "skip_test": true,
                "pattern": "\\d*",
                "log": "wazuh",
                "end_match": "wazuh",
                "captured_groups": []
            },
            {
                "description": "With capture group, match all",
                "ignore_result": true,
                "pattern": "(\\w*)",
                "log": "wazuh",
                "end_match": "h",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "With capture group, match 0-0",
                "ignore_result": true,
                "__know_issue": "Return one byte before log starts ",
                "skip_test": true,
                "pattern": "(\\d*)",
                "log": "wazuh",
                "end_match": "wazuh",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Without capture group, match all (And flags)",
                "ignore_result": true,
                "debug": false,
                "pattern": "^\\w*$",
                "log": "wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "With capture group, match all (And flags)",
                "ignore_result": true,
                "pattern": "^(\\w*)$",
                "log": "wazuh",
                "end_match": "h",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Without capture group, parcial match (And flags)",
                "pattern": "^\\w*$",
                "log": "wazuh ",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "With capture group, match all (And flags)",
                "pattern": "^(\\w*)$",
                "log": "wazuh ",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Without capture group, match one character.",
                "pattern": "\\w*",
                "log": "w",
                "end_match": "w",
                "captured_groups": []
            },
            {
                "description": "With capture group, match one character.",
                "pattern": "(\\w*)",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Without capture group, match all (And flags), match one character.",
                "pattern": "^\\w*$",
                "log": "w",
                "end_match": "w",
                "captured_groups": []
            },
            {
                "description": "With capture group, match all (And flags), match one character.",
                "pattern": "^(\\w*)$",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Without capture group, empty (And flags)",
                "ignore_result": true,
                "__know_issue": "Return one byte before log starts ",
                "pattern": "^\\w*$",
                "log": "",
                "end_match": "",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "With capture group, match 0-0. Empty string",
                "ignore_result": true,
                "__know_issue": "Return one byte before log starts ",
                "skip_test": true,
                "pattern": "(\\d*)",
                "log": "",
                "end_match": "",
                "captured_groups": [
                    ""
                ]
            }
        ]
    },
    {
        "description": "[Coverage] Lazy pattern, greedy match - backslash with '+' modifier. st_error, error handling, parcial match and rewind.",
        "batch_test": [
            {
                "description": "Save 6 token position, and restore the first.",
                "pattern": "\\w+_1 \\w+_2 \\w+_3 \\w+_4 \\w+_5 \\w+_6",
                "log": "wa_11 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the second.",
                "pattern": "\\w+_1 \\w+_2 \\w+_3 \\w+_4 \\w+_5 \\w+_6",
                "log": "wa_1 wa_22 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the third.",
                "pattern": "\\w+_1 \\w+_2 \\w+_3 \\w+_4 \\w+_5 \\w+_6",
                "log": "wa_1 wa_2 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the fourth.",
                "pattern": "\\w+_1 \\w+_2 \\w+_3 \\w+_4 \\w+_5 \\w+_6",
                "log": "wa_1 wa_2 wa_3 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the fifth.",
                "pattern": "\\w+_1 \\w+_2 \\w+_3 \\w+_4 \\w+_5 \\w+_6",
                "log": "wa_1 wa_2 wa_3 wa_4 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the sixth.",
                "pattern": "\\w+_1 \\w+_2 \\w+_3 \\w+_4 \\w+_5 \\w+_6",
                "log": "wa_1 wa_2 wa_3 wa_4 wa_5 wa_1 wa_2 wa_3 wa_4 wa_5 wa_6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the first. But the first should match with the next character.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "log": "z1x1 x2 x3 x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the second. But the second should match with the next character.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "log": "z1 x2x2 x3 x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the third. But the third should match with the next character.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "log": "z1 x2x2 x3 x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the fourth. But the fourth should match with the next character.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "log": "z1 x2 x3 x4x4 x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the fifth. But the fifth should match with the next character.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "ignore_result": true,
                "__knowIssue": "#XXXX The stacktrace has a static size",
                "log": "z1 x2 x3 x4 x5x5 x6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "Save 6 token position, and restore the sixth. But the sixth should match with the next character.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6",
                "log": "z1 x2 x3 x4 x5 x6x6",
                "ignore_result": true,
                "__knowIssue": "#XXXX The stacktrace has a static size",
                "end_match": "6",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Coverage] Lazy pattern, greedy match - backslash with '+' modifier. The next token does include the map characters of the current token and has no modifier.",
        "batch_test": [
            {
                "description": "Min size: No match, no items in the log to consume",
                "pattern": "\\d+\\d",
                "log": "5",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Min size: No match, no items in the log to consume",
                "pattern": "(\\d+)\\d",
                "log": "5",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Min size: Minimum match with capture group",
                "pattern": "(\\d+)\\w",
                "log": "12",
                "end_match": "2",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Min size: Minimum match with capture group",
                "pattern": "\\d+(\\w)",
                "log": "12",
                "end_match": "2",
                "captured_groups": [
                    "2"
                ]
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern",
                "pattern": "\\d+\\w",
                "log": "12345",
                "end_match": "2345",
                "captured_groups": []
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern, only capture the first character",
                "pattern": "(\\d+)\\w",
                "log": "12345",
                "end_match": "2345",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern",
                "pattern": "\\d+(\\w)",
                "log": "12345",
                "end_match": "2345",
                "captured_groups": [
                    "2"
                ]
            },
            {
                "description": "Min size: No match, no items in the log to consume (With flags).",
                "pattern": "^\\d+\\d",
                "log": "5",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Min size: No match, no items in the log to consume (With flags).",
                "pattern": "^(\\d+)\\d",
                "log": "5",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Min size: Minimum match with capture group (With flags).",
                "pattern": "^(\\d+)\\w$",
                "log": "12",
                "end_match": "2",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Min size: Minimum match with capture group (With flags).",
                "pattern": "^\\d+(\\w)$",
                "log": "12",
                "end_match": "2",
                "captured_groups": [
                    "2"
                ]
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern (With flags).",
                "pattern": "^\\d+\\w$",
                "log": "12345",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern, capture the first 4 character, because the $ flag.",
                "__know_issue": "regex returns the pointer to '2' character. ",
                "pattern": "^(\\d+)\\w$",
                "log": "12345",
                "end_match": "5",
                "captured_groups": [
                    "1234"
                ]
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern (With flags).",
                "pattern": "^\\d+(\\w)$",
                "log": "12345",
                "end_match": "5",
                "captured_groups": [
                    "5"
                ]
            },
            {
                "description": "Lazy pattern: Move as fast as possible over the pattern (With flags).",
                "pattern": "^\\d+(\\w)$",
                "log": "12345&&&&&&&",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Coverage] Lazy pattern, greedy match - backslash with '+' modifier. The next token does not include the map characters of the current token and has no modifier.",
        "batch_test": [
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. 1 character",
                "pattern": "\\w+\\s",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all",
                "pattern": "\\w+\\s",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. 1 character + capture group.",
                "pattern": "(\\w+)\\s",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token with blackslash.  ok_here == -1. Match all. 1 character + capture all.",
                "pattern": "(\\w+\\s)",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. Parcial capture group case.",
                "pattern": "(\\w+)\\s",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. 1 character",
                "pattern": "\\w+ ",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all",
                "pattern": "\\w+ ",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. 1 character + capture group.",
                "pattern": "(\\w+) ",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. 1 character + capture all.",
                "pattern": "(\\w+ )",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. Parcial capture group case.",
                "pattern": "(\\w+) ",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all",
                "pattern": "\\w+\\s1",
                "log": "wazuh 1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. 1 character + capture group.",
                "pattern": "(\\w+)\\s1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. 1 character + capture all.",
                "pattern": "(\\w+\\s)1",
                "log": "w 1",
                "end_match": "1",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Next token with blackslash. ok_here ==  -1. Match all. Parcial capture group case.",
                "pattern": "(\\w+)\\s1",
                "log": "wazuh 1",
                "end_match": "1",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match. 1 character",
                "pattern": "\\w+\\s1",
                "log": "w 123",
                "end_match": "123",
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match",
                "pattern": "\\w+ 1",
                "log": "wazuh 123",
                "end_match": "123",
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match. 1 character + capture group.",
                "pattern": "(\\w+) 1",
                "log": "w 123",
                "end_match": "123",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match. 1 character + capture all.",
                "pattern": "(\\w+ )1",
                "log": "w 123",
                "end_match": "123",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match. Parcial capture group case.",
                "pattern": "(\\w+) 1",
                "log": "wazuh 123",
                "end_match": "123",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. 1 character (With flags).",
                "pattern": "^\\w+\\s$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all (With flags).",
                "pattern": "^\\w+\\s$",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. 1 character + capture group. (With flags).",
                "pattern": "^(\\w+)\\s$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token with blackslash.  ok_here == -1. Match all. 1 character + capture all. (With flags).",
                "pattern": "^(\\w+\\s)$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Next token with blackslash. ok_here == -1. Match all. Parcial capture group case. (With flags).",
                "pattern": "^(\\w+)\\s$",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. 1 character (With flags).",
                "pattern": "^\\w+ $",
                "log": "w ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all (With flags).",
                "pattern": "^\\w+ $",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. 1 character + capture group (With flags).",
                "pattern": "^(\\w+) $",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. 1 character + capture all (With flags).",
                "pattern": "^(\\w+ )$",
                "log": "w ",
                "end_match": " ",
                "captured_groups": [
                    "w "
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. Parcial capture group case (With flags).",
                "pattern": "^(\\w+) $",
                "log": "wazuh ",
                "end_match": " ",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. Ends pattern (With flags) before log.",
                "pattern": "^\\w+ $",
                "log": "wazuh -",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Next token without blackslash. ok_here == -1. Match all. Ends pattern (With flags and capture all) before log.",
                "pattern": "^(\\w+ )$",
                "log": "wazuh -",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Coverage] Regex, only backslash with '+' modifier.",
        "batch_test": [
            {
                "description": "Without capture group, match all",
                "ignore_result": true,
                "debug": false,
                "pattern": "\\w+",
                "log": "wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "With capture group, match all",
                "ignore_result": true,
                "debug": false,
                "pattern": "(\\w+)",
                "log": "wazuh",
                "end_match": "h",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Without capture group, match all (And flags)",
                "ignore_result": true,
                "debug": false,
                "pattern": "^\\w+$",
                "log": "wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "With capture group, match all (And flags)",
                "ignore_result": true,
                "debug": false,
                "pattern": "^(\\w+)$",
                "log": "wazuh",
                "end_match": "h",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Without capture group, parcial match (And flags)",
                "pattern": "^\\w+$",
                "log": "wazuh ",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "With capture group, match all (And flags)",
                "pattern": "^(\\w+)$",
                "log": "wazuh ",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Without capture group, match one character.",
                "pattern": "\\w+",
                "log": "w",
                "end_match": "w",
                "captured_groups": []
            },
            {
                "description": "With capture group, match one character.",
                "pattern": "(\\w+)",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            },
            {
                "description": "Without capture group, match all (And flags), match one character.",
                "pattern": "^\\w+$",
                "log": "w",
                "end_match": "w",
                "captured_groups": []
            },
            {
                "description": "With capture group, match all (And flags), match one character.",
                "pattern": "^(\\w+)$",
                "log": "w",
                "end_match": "w",
                "captured_groups": [
                    "w"
                ]
            }
        ]
    },
    {
        "description": "[Coverage] Regex, only backslash without modifiers ('*', '+')",
        "batch_test": [
            {
                "description": "Without capture group, match all",
                "pattern": "\\w\\w\\s\\S\\S\\S\\S\\S",
                "log": "hi wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "Without capture group, parcial match",
                "pattern": "\\w\\w\\s\\S\\S\\S\\S\\S",
                "log": "hi waz",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Without capture group, parcial match and then match all",
                "pattern": "\\w\\w\\s\\S\\S\\S\\S\\S",
                "log": "hi waz hi wazu.",
                "end_match": ".",
                "captured_groups": []
            },
            {
                "description": "With capture group, match all",
                "pattern": "\\w(\\w\\s\\S)\\S(\\S\\S\\S)",
                "log": "hi wazuh",
                "end_match": "h",
                "captured_groups": [
                    "i w",
                    "zuh"
                ]
            },
            {
                "description": "With capture group, parcial match",
                "pattern": "(\\w\\w)\\s\\S\\S\\S\\S\\S",
                "log": "hi waz",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "With capture group, parcial match and then match all",
                "pattern": "(\\w\\w)\\s(\\S\\S\\S\\S\\S)",
                "log": "hi waz hi wazuh.",
                "end_match": "h.",
                "captured_groups": [
                    "hi",
                    "wazuh"
                ]
            },
            {
                "description": "With capture group, parcial match and then match all",
                "__knownIssue:": "The capture groups cannot be adjacent to each other",
                "ignore_result": true,
                "pattern": "(\\w\\w\\s)(\\S\\S\\S\\S\\S)",
                "log": "hi waz hi wazuh.",
                "end_match": "h.",
                "captured_groups": [
                    "hi ",
                    "wazuh"
                ]
            },
            {
                "description": "With capture group, parcial match and then match all (1 group)",
                "pattern": "(\\w\\w\\s\\S\\S\\S\\S\\S)\\p$",
                "log": "hi waz hi wazuh.",
                "end_match": ".",
                "captured_groups": [
                    "hi wazuh"
                ]
            }
        ]
    },
    {
        "description": "[Coverage] Regex, only charmap without backslash",
        "batch_test": [
            {
                "description": "Match between pattern and regex. pattern[0] != '('.",
                "pattern": "hi wazuh",
                "log": "hi wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "Match between pattern and regex. With capture group",
                "pattern": "(hi) (wazuh)",
                "log": "hi wazuh",
                "end_match": "h",
                "captured_groups": [
                    "hi",
                    "wazuh"
                ]
            },
            {
                "description": "Match pattern but fail because log dont ends.",
                "pattern": "hi wazuh$",
                "log": "hi wazuh 123",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Match pattern (with group) but fail because log dont ends.",
                "pattern": "(hi) (wazuh)$",
                "log": "hi wazuh 123",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Dont match at all .pattern[0] != '('.",
                "pattern": "hi wazuh",
                "log": "bye wazuh",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "match with prefix.",
                "pattern": "(hi) (wazuh)",
                "log": "prefixhi wazuh",
                "end_match": "h",
                "captured_groups": [
                    "hi",
                    "wazuh"
                ]
            },
            {
                "description": "match with sufix.",
                "pattern": "(hi) (wazuh)",
                "log": "fixhi wazuhsub",
                "end_match": "hsub",
                "captured_groups": [
                    "hi",
                    "wazuh"
                ]
            },
            {
                "description": "match with continue capture group.",
                "ignore_result": true,
                "__knownIssue:": "The capture groups cannot be adjacent to each other",
                "pattern": "(hi)(wazuh)",
                "log": "hiwazuh",
                "end_match": "h",
                "captured_groups": [
                    "hi",
                    "wazuh"
                ]
            },
            {
                "description": "match with continue capture group and context",
                "ignore_result": true,
                "__knownIssue:": "The capture groups cannot be adjacent to each other",
                "pattern": "(hi)(wazuh)",
                "log": "prefixhiwazuhsub",
                "end_match": "hsub",
                "captured_groups": [
                    "hi",
                    "wazuh"
                ]
            }
        ]
    },
    {
        "description": "[Coverage] Regex, only charmap + END/BEGIN flags and st_error without backslash",
        "batch_test": [
            {
                "description": "Pattern ends and the END_SET is set. (ENDOFFILE(pt) true)",
                "pattern": "hi wazuh",
                "log": "hi wazuh",
                "end_match": "h",
                "captured_groups": []
            },
            {
                "description": "Empty pattern END_SET and BEGIN_SET are set.",
                "pattern": "^$",
                "log": "hi wazuh",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Empty pattern END_SET and BEGIN_SET are set.",
                "ignore_result": true,
                "__knownIssue:": "empty group?",
                "pattern": "(^$)",
                "log": "",
                "end_match": "",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Empty pattern END_SET and BEGIN_SET are set.",
                "ignore_result": true,
                "__knownIssue:": "empty group?",
                "pattern": "^()$",
                "log": "",
                "end_match": "",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Pattern ends and the END_SET is not set.",
                "pattern": "hi wazuh",
                "log": "hi wazuh!",
                "end_match": "h!",
                "captured_groups": []
            },
            {
                "description": "partially matched and then backward (st error test).",
                "pattern": "(hi) (wazuh)",
                "log": "XX hi wa hi wazuhXX",
                "end_match": "hXX",
                "captured_groups": [
                    "hi",
                    "wazuh"
                ]
            },
            {
                "description": "partially matched and then return (st error + BEGIN_SET test).",
                "pattern": "^(hi) (wazuh)",
                "log": "hi wa hi wazuhXX",
                "end_match": null,
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Coverage] Loop on all sub patterns without capture groups",
        "batch_test": [
            {
                "description": "Loop on all sub patterns, without match",
                "pattern": "^hi|bye$|^$",
                "log": "123456",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Loop on all sub patterns, match",
                "pattern": "^hi|bye$|^$|\\w+\\d.|\\p*",
                "log": "123456.",
                "end_match": ".",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Memory test] regex_matching alloc test: copy reg size.",
        "batch_test": [
            {
                "description": "Create 20 patterns, 22 capture groups and match last.",
                "__sub_string_size": "((36 gruopos x 2 know bug) + 1 null)  x 8 size = 584 bytes",
                "__prts_main_array": " (20 pattern + 1 null)  x 8 size = 168 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 168",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_2": "(4 group x2 + 1 null)  x 8 size = 72 bytes",
                "__prts_items_array_3": "(5 group x2 + 1 null)  x 8 size = 88 bytes",
                "__prts_items_array_4": "(6 group x2 + 1 null)  x 8 size = 104 bytes",
                "__prts_items_array_5": "(7 group x2 + 1 null)  x 8 size = 120 bytes",
                "__prts_items_array_6": "(8 group x2 + 1 null)  x 8 size = 136 bytes",
                "__prts_items_array_7": "(9 group x2 + 1 null)  x 8 size = 152 bytes",
                "__prts_items_array_8": "(10 group x2 + 1 null)  x 8 size = 168 bytes",
                "__prts_items_array_9": "(11 group x2 + 1 null)  x 8 size = 184 bytes",
                "__prts_items_array_10": "(12 group x2 + 1 null)  x 8 size = 200 bytes",
                "__prts_items_array_11": "(13 group x2 + 1 null)  x 8 size = 216 bytes",
                "__prts_items_array_12": "(14 group x2 + 1 null)  x 8 size = 232 bytes",
                "__prts_items_array_13": "(15 group x2 + 1 null)  x 8 size = 248 bytes",
                "__prts_items_array_14": "(16 group x2 + 1 null)  x 8 size = 264 bytes",
                "__prts_items_array_15": "(17 group x2 + 1 null)  x 8 size = 280 bytes",
                "__prts_items_array_16": "(18 group x2 + 1 null)  x 8 size = 296 bytes",
                "__prts_items_array_17": "(19 group x2 + 1 null)  x 8 size = 312 bytes",
                "__prts_items_array_18": "(20 group x2 + 1 null)  x 8 size = 328 bytes",
                "__prts_items_array_19": "(21 group x2 + 1 null)  x 8 size = 344 bytes",
                "__prts_items_array_20": "(36 group x2 + 1 null)  x 8 size = 584 bytes",
                "__prts_items_array_21": "0x0",
                "pattern": "^01cg field_01=(\\d+)|^04cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+)|^05cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+)|^06cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+)|^07cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+)|^08cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+)|^09cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+)|^10cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+)|^11cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+)|^12cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+)|^13cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+)|^14cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+)|^15cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+)|^16cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+)|^17cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+)|^18cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+)|^19cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+)|^20cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+)|^21cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+) field_21=(\\d+)|^36cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+) field_21=(\\d+) field_22=(\\d+) field_23=(\\d+) field_24=(\\d+) field_25=(\\d+) field_26=(\\d+) field_27=(\\d+) field_28=(\\d+) field_29=(\\d+) field_30=(\\d+) field_31=(\\d+) field_32=(\\d+) field_33=(\\d+) field_34=(\\d+) field_35=(\\d+) field_36=(\\d\\d\\d)",
                "log": "36cg field_01=001 field_02=002 field_03=003 field_04=004 field_05=005 field_06=006 field_07=007 field_08=008 field_09=009 field_10=010 field_11=011 field_12=012 field_13=013 field_14=014 field_15=015 field_16=016 field_17=017 field_18=018 field_19=019 field_20=020 field_21=021 field_22=022 field_23=023 field_24=024 field_25=025 field_26=026 field_27=027 field_28=028 field_29=029 field_30=030 field_31=031 field_32=032 field_33=033 field_34=034 field_35=035 field_36=036",
                "end_match": "6",
                "captured_groups": [
                    "001",
                    "002",
                    "003",
                    "004",
                    "005",
                    "006",
                    "007",
                    "008",
                    "009",
                    "010",
                    "011",
                    "012",
                    "013",
                    "014",
                    "015",
                    "016",
                    "017",
                    "018",
                    "019",
                    "020",
                    "021",
                    "022",
                    "023",
                    "024",
                    "025",
                    "026",
                    "027",
                    "028",
                    "029",
                    "030",
                    "031",
                    "032",
                    "033",
                    "034",
                    "035",
                    "036"
                ]
            }
        ]
    },
    {
        "description": "[Memory test] regex_matching expand test: Incremental capture groups and match last.",
        "batch_test": [
            {
                "description": "Inizialize regex matching with capture grup, min size (1 patter, 1 capture).",
                "__sub_string_size": "((1 pattern x 2 know bug) + 1 null)  x 8 size = 24 bytes",
                "__prts_main_array": " (1 pattern + 1 null)  x 8 size = 16 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 16",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_array_2": "0x0",
                "pattern": "hi (\\w+).",
                "log": "Hi wazuh.",
                "end_match": ".",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Resize x 36 incremental capture groups and match.",
                "__sub_string_size": "((36 gruopos x 2 know bug) + 1 null)  x 8 size = 584 bytes",
                "__prts_main_array": " (1 pattern + 1 null)  x 8 size = 16 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 16",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_2": "(4 group x2 + 1 null)  x 8 size = 72 bytes",
                "__prts_items_array_3": "(5 group x2 + 1 null)  x 8 size = 88 bytes",
                "__prts_items_array_4": "(6 group x2 + 1 null)  x 8 size = 104 bytes",
                "__prts_items_array_5": "(7 group x2 + 1 null)  x 8 size = 120 bytes",
                "__prts_items_array_6": "(8 group x2 + 1 null)  x 8 size = 136 bytes",
                "__prts_items_array_7": "(9 group x2 + 1 null)  x 8 size = 152 bytes",
                "__prts_items_array_8": "(10 group x2 + 1 null)  x 8 size = 168 bytes",
                "__prts_items_array_9": "(11 group x2 + 1 null)  x 8 size = 184 bytes",
                "__prts_items_array_10": "(12 group x2 + 1 null)  x 8 size = 200 bytes",
                "__prts_items_array_11": "(13 group x2 + 1 null)  x 8 size = 216 bytes",
                "__prts_items_array_12": "(14 group x2 + 1 null)  x 8 size = 232 bytes",
                "__prts_items_array_13": "(15 group x2 + 1 null)  x 8 size = 248 bytes",
                "__prts_items_array_14": "(16 group x2 + 1 null)  x 8 size = 264 bytes",
                "__prts_items_array_15": "(17 group x2 + 1 null)  x 8 size = 280 bytes",
                "__prts_items_array_16": "(18 group x2 + 1 null)  x 8 size = 296 bytes",
                "__prts_items_array_17": "(19 group x2 + 1 null)  x 8 size = 312 bytes",
                "__prts_items_array_18": "(20 group x2 + 1 null)  x 8 size = 328 bytes",
                "__prts_items_array_19": "(21 group x2 + 1 null)  x 8 size = 344 bytes",
                "__prts_items_array_20": "(36 group x2 + 1 null)  x 8 size = 584 bytes",
                "__prts_items_array_21": "0x0",
                "pattern": "^36cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+) field_21=(\\d+) field_22=(\\d+) field_23=(\\d+) field_24=(\\d+) field_25=(\\d+) field_26=(\\d+) field_27=(\\d+) field_28=(\\d+) field_29=(\\d+) field_30=(\\d+) field_31=(\\d+) field_32=(\\d+) field_33=(\\d+) field_34=(\\d+) field_35=(\\d+) field_36=(\\d\\d\\d)",
                "log": "36cg field_01=001 field_02=002 field_03=003 field_04=004 field_05=005 field_06=006 field_07=007 field_08=008 field_09=009 field_10=010 field_11=011 field_12=012 field_13=013 field_14=014 field_15=015 field_16=016 field_17=017 field_18=018 field_19=019 field_20=020 field_21=021 field_22=022 field_23=023 field_24=024 field_25=025 field_26=026 field_27=027 field_28=028 field_29=029 field_30=030 field_31=031 field_32=032 field_33=033 field_34=034 field_35=035 field_36=036",
                "end_match": "6",
                "captured_groups": [
                    "001",
                    "002",
                    "003",
                    "004",
                    "005",
                    "006",
                    "007",
                    "008",
                    "009",
                    "010",
                    "011",
                    "012",
                    "013",
                    "014",
                    "015",
                    "016",
                    "017",
                    "018",
                    "019",
                    "020",
                    "021",
                    "022",
                    "023",
                    "024",
                    "025",
                    "026",
                    "027",
                    "028",
                    "029",
                    "030",
                    "031",
                    "032",
                    "033",
                    "034",
                    "035",
                    "036"
                ]
            },
            {
                "description": "Go back to 1 pattern and 1 capture groups.",
                "__sub_string_size": "((1 pattern x 2 know bug) + 1 null)  x 8 size = 24 bytes",
                "__prts_main_array": " (1 pattern + 1 null)  x 8 size = 16 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 16",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_array_2": "0x0",
                "pattern": "hi (\\w+).",
                "log": "Hi wazuh.",
                "end_match": ".",
                "captured_groups": [
                    "wazuh"
                ]
            }
        ]
    },
    {
        "description": "[Memory test] regex_matching expand test: Incremental patterns and match last.",
        "batch_test": [
            {
                "description": "Inizialize regex matching with a capture group, min size (1 patter, 1 capture).",
                "__sub_string_size": "((1 pattern x 2 know bug) + 1 null)  x 8 size = 24 bytes",
                "__prts_main_array": " (1 pattern + 1 null)  x 8 size = 16 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 16",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_array_2": "0x0",
                "pattern": "hi (\\w+).",
                "log": "Hi wazuh.",
                "end_match": ".",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Resize x 38 incremental patterns and match last.",
                "__sub_string_size": "((1 gruopos x 2 know bug) + 1 null)  x 8 size = 24 bytes",
                "__prts_main_array": " (38 pattern + 1 null)  x 8 size = 312 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 312",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_2": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_3": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_4": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_5": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_6": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_7": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_8": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_9": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_10": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_11": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_12": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_13": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_14": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_15": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_16": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_17": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_18": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_19": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_20": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_21": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_22": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_23": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_24": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_25": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_26": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_27": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_28": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_29": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_30": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_31": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_32": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_33": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_34": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_35": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_36": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_37": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_38": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_39": "0x0",
                "pattern": "^01cg field_01=(\\d+)|^04cg field_01=(\\d+)|^05cg field_01=(\\d+)|^06cg field_01=(\\d+)|^07cg field_01=(\\d+)|^08cg field_01=(\\d+)|^09cg field_01=(\\d+)|^10cg field_01=(\\d+)|^11cg field_01=(\\d+)|^12cg field_01=(\\d+)|^13cg field_01=(\\d+)|^14cg field_01=(\\d+)|^15cg field_01=(\\d+)|^16cg field_01=(\\d+)|^17cg field_01=(\\d+)|^18cg field_01=(\\d+)|^19cg field_01=(\\d+)|^20cg field_01=(\\d+)|^21cg field_01=(\\d+)|^22cg field_01=(\\d+)|^23cg field_01=(\\d+)|^24cg field_01=(\\d+)|^25cg field_01=(\\d+)|^26cg field_01=(\\d+)|^27cg field_01=(\\d+)|^28cg field_01=(\\d+)|^29cg field_01=(\\d+)|^30cg field_01=(\\d+)|^31cg field_01=(\\d+)|^32cg field_01=(\\d+)|^33cg field_01=(\\d+)|^34cg field_01=(\\d+)|^35cg field_01=(\\d+)|^36cg field_01=(\\d+)|^37cg field_01=(\\d+)|^38cg field_01=(\\d\\d\\d)",
                "log": "38cg field_01=001",
                "end_match": "1",
                "captured_groups": [
                    "001"
                ]
            }
        ]
    },
    {
        "description": "[Memory test] regex_matching expand test: Incremental capture groups and patterns, then match last.",
        "batch_test": [
            {
                "description": "Inizialize regex matching with capture grup, min size (1 patter, 1 capture).",
                "__sub_string_size": "((1 pattern x 2 know bug) + 1 null)  x 8 size = 24 bytes",
                "__prts_main_array": " (1 pattern + 1 null)  x 8 size = 16 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 16",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_array_2": "0x0",
                "pattern": "hi (\\w+).",
                "log": "Hi wazuh.",
                "end_match": ".",
                "captured_groups": [
                    "wazuh"
                ]
            },
            {
                "description": "Resize x 20 patterns, 2236 incremental capture groups and match last.",
                "__sub_string_size": "((36 gruopos x 2 know bug) + 1 null)  x 8 size = 584 bytes",
                "__prts_main_array": " (20 pattern + 1 null)  x 8 size = 168 bytes",
                "__prts_items_array": "size of array d_size->prts_str_size == size of array prts_str == prts_str_alloc_size = 168",
                "__prts_items_array_1": "(1 group x2 + 1 null)  x 8 size = 24 bytes",
                "__prts_items_array_2": "(4 group x2 + 1 null)  x 8 size = 72 bytes",
                "__prts_items_array_3": "(5 group x2 + 1 null)  x 8 size = 88 bytes",
                "__prts_items_array_4": "(6 group x2 + 1 null)  x 8 size = 104 bytes",
                "__prts_items_array_5": "(7 group x2 + 1 null)  x 8 size = 120 bytes",
                "__prts_items_array_6": "(8 group x2 + 1 null)  x 8 size = 136 bytes",
                "__prts_items_array_7": "(9 group x2 + 1 null)  x 8 size = 152 bytes",
                "__prts_items_array_8": "(10 group x2 + 1 null)  x 8 size = 168 bytes",
                "__prts_items_array_9": "(11 group x2 + 1 null)  x 8 size = 184 bytes",
                "__prts_items_array_10": "(12 group x2 + 1 null)  x 8 size = 200 bytes",
                "__prts_items_array_11": "(13 group x2 + 1 null)  x 8 size = 216 bytes",
                "__prts_items_array_12": "(14 group x2 + 1 null)  x 8 size = 232 bytes",
                "__prts_items_array_13": "(15 group x2 + 1 null)  x 8 size = 248 bytes",
                "__prts_items_array_14": "(16 group x2 + 1 null)  x 8 size = 264 bytes",
                "__prts_items_array_15": "(17 group x2 + 1 null)  x 8 size = 280 bytes",
                "__prts_items_array_16": "(18 group x2 + 1 null)  x 8 size = 296 bytes",
                "__prts_items_array_17": "(19 group x2 + 1 null)  x 8 size = 312 bytes",
                "__prts_items_array_18": "(20 group x2 + 1 null)  x 8 size = 328 bytes",
                "__prts_items_array_19": "(21 group x2 + 1 null)  x 8 size = 344 bytes",
                "__prts_items_array_20": "(36 group x2 + 1 null)  x 8 size = 584 bytes",
                "__prts_items_array_21": "0x0",
                "pattern": "^01cg field_01=(\\d+)|^04cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+)|^05cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+)|^06cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+)|^07cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+)|^08cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+)|^09cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+)|^10cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+)|^11cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+)|^12cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+)|^13cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+)|^14cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+)|^15cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+)|^16cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+)|^17cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+)|^18cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+)|^19cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+)|^20cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+)|^21cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+) field_21=(\\d+)|^36cg field_01=(\\d+) field_02=(\\d+) field_03=(\\d+) field_04=(\\d+) field_05=(\\d+) field_06=(\\d+) field_07=(\\d+) field_08=(\\d+) field_09=(\\d+) field_10=(\\d+) field_11=(\\d+) field_12=(\\d+) field_13=(\\d+) field_14=(\\d+) field_15=(\\d+) field_16=(\\d+) field_17=(\\d+) field_18=(\\d+) field_19=(\\d+) field_20=(\\d+) field_21=(\\d+) field_22=(\\d+) field_23=(\\d+) field_24=(\\d+) field_25=(\\d+) field_26=(\\d+) field_27=(\\d+) field_28=(\\d+) field_29=(\\d+) field_30=(\\d+) field_31=(\\d+) field_32=(\\d+) field_33=(\\d+) field_34=(\\d+) field_35=(\\d+) field_36=(\\d\\d\\d)",
                "log": "36cg field_01=001 field_02=002 field_03=003 field_04=004 field_05=005 field_06=006 field_07=007 field_08=008 field_09=009 field_10=010 field_11=011 field_12=012 field_13=013 field_14=014 field_15=015 field_16=016 field_17=017 field_18=018 field_19=019 field_20=020 field_21=021 field_22=022 field_23=023 field_24=024 field_25=025 field_26=026 field_27=027 field_28=028 field_29=029 field_30=030 field_31=031 field_32=032 field_33=033 field_34=034 field_35=035 field_36=036",
                "end_match": "6",
                "captured_groups": [
                    "001",
                    "002",
                    "003",
                    "004",
                    "005",
                    "006",
                    "007",
                    "008",
                    "009",
                    "010",
                    "011",
                    "012",
                    "013",
                    "014",
                    "015",
                    "016",
                    "017",
                    "018",
                    "019",
                    "020",
                    "021",
                    "022",
                    "023",
                    "024",
                    "025",
                    "026",
                    "027",
                    "028",
                    "029",
                    "030",
                    "031",
                    "032",
                    "033",
                    "034",
                    "035",
                    "036"
                ]
            }
        ]
    },
    {
        "description": "[Functionality] Supported expression tests - Character Maps [\\w, \\d, \\s, \\W, \\D, \\S, \\p, \\t, \\.].",
        "batch_test": [
            {
                "description": "\\w test: Includes all letters, digits, @ and _ characters.",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\w+)' pattern",
                "pattern": "(\\w+\\w)$",
                "log": "\t\r !\"#$%&()*+,./:;<=>?[\\]^`{|}~0123456789_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
                "end_match": "z",
                "captured_groups": [
                    "0123456789_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
                ]
            },
            {
                "description": "\\d test: Only digits.",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\d+)' pattern",
                "pattern": "(\\d+\\d)$",
                "log": "\t\r !\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
                "end_match": "9",
                "captured_groups": [
                    "0123456789"
                ]
            },
            {
                "description": "\\s test: space character ' '.",
                "pattern": "(\\s+)",
                "log": "\t\r!\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 ",
                "end_match": " ",
                "captured_groups": [
                    " "
                ]
            },
            {
                "description": "\\t test: tab character '\\t'.",
                "pattern": "(\\t+)",
                "log": "\r !\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\t",
                "end_match": "\t",
                "captured_groups": [
                    "\t"
                ]
            },
            {
                "description": "\\p test: symbols characters '()*+,-.:;<=>?[]!\"'#$%&|{}'.",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\p+)' pattern",
                "pattern": "(\\p+\\p)$",
                "log": "\r\t /\\^`~_@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789()*+,-.:;<=>?[]!\"'#$%&|{}",
                "end_match": "}",
                "captured_groups": [
                    "()*+,-.:;<=>?[]!\"'#$%&|{}"
                ]
            },
            {
                "description": "\\W test: Anything not \\w.",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\W+)' pattern",
                "pattern": "(\\W+\\W)$",
                "log": "0123456789_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\t\r !\"#$%&()*+,./:;<=>?[\\]^`{|}~",
                "end_match": "~",
                "captured_groups": [
                    "\t\r !\"#$%&()*+,./:;<=>?[\\]^`{|}~"
                ]
            },
            {
                "description": "\\D test: Anything not \\d.",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\D+)' pattern",
                "pattern": "(\\D+\\D)$",
                "log": "0123456789_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\t !\"#$%&()*+,./:;<=>?[\\]^`{|}~",
                "end_match": "~",
                "captured_groups": [
                    "_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\t !\"#$%&()*+,./:;<=>?[\\]^`{|}~"
                ]
            },
            {
                "description": "\\S test: Anything not \\s.",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\S+)' pattern",
                "pattern": "(\\S+\\S)$",
                "log": " \r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
                "end_match": "9",
                "captured_groups": [
                    "\r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
                ]
            },
            {
                "description": "\\. test: Anything",
                "__knownIssue:": "The pattern was designed this way due to know issue. Workaround for '(\\S+)' pattern",
                "pattern": "(\\.+\\.)$",
                "log": " \r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
                "end_match": "9",
                "captured_groups": [
                    " \r\t!\"#$%&()*+,./:;<=>?[\\]^`{|}~_-@ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
                ]
            }
        ]
    },
    {
        "description": "[Functionality] Modifiers (+ and *)",
        "batch_test": [
            {
                "description": "[+] It should not match since there are no characters of the type `\\d`.",
                "pattern": "(\\d+)",
                "log": "asd_ _qwe",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "[+] It should match one time",
                "pattern": "(\\d+)",
                "log": "asd_1_qwe",
                "end_match": "1_qwe",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "[+]",
                "pattern": "(\\d+)",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "debug": false,
                "log": "asd_12_qwe",
                "end_match": "2_qwe",
                "captured_groups": [
                    "12"
                ]
            },
            {
                "description": "[+]",
                "pattern": "(\\d+)",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "log": "asd_123_qwe",
                "end_match": "3_qwe",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "[*] It should not match since there are no characters of the type `\\d`.",
                "skip_test": true,
                "pattern": "(\\d*)",
                "ignore_result": true,
                "log": " asd_ _qwe",
                "end_match": " asd_ _qwe",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "[*] It should match one time",
                "skip_test": true,
                "pattern": "(\\d*)",
                "log": "asd_1_qwe",
                "end_match": "1_qwe",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "[*]",
                "skip_test": true,
                "pattern": "(\\d*)",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "log": "asd_12_qwe",
                "end_match": "2_qwe",
                "captured_groups": [
                    "12"
                ]
            },
            {
                "description": "[+]",
                "skip_test": true,
                "pattern": "(\\d*)",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "log": "asd_123_qwe",
                "end_match": "3_qwe",
                "captured_groups": [
                    "123"
                ]
            }
        ]
    },
    {
        "description": "[Functionality] Special characters escaping (\\$ \\( \\) \\\\ \\| \\<)",
        "batch_test": [
            {
                "description": "Using the '\\p+' token to test matching all the special characters with capture group. Note: the character '\\' is not captured by the token '\\p'.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "(\\p+)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<"
                ]
            },
            {
                "description": "Using the '\\p+' token to test matching all the special characters w/o capture group. Note: the character '\\' is not captured by the token '\\p'.",
                "pattern": "\\p+",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\p*' token to test matching all the special characters with capture group. Note: the character '\\' is not captured by the token '\\p'.",
                "pattern": "Special characters are (\\p*)",
                "log": "Special characters are $()|<\\",
                "end_match": "<\\",
                "captured_groups": [
                    "$()|<"
                ]
            },
            {
                "description": "Using the '\\p*' token to test matching all the special characters w/o capture group. Note: the character '\\' is not captured by the token '\\p'.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are \\p*",
                "log": "Special characters are $()|<\\",
                "end_match": "<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\.+' token to test matching the character '\\' with capture group.",
                "pattern": "Backslash character is (\\.+)",
                "log": "Backslash character is \\",
                "end_match": "\\",
                "captured_groups": [
                    "\\"
                ]
            },
            {
                "description": "Using the '\\.+' token to test matching the character '\\' w/o capture group.",
                "pattern": "Backslash character is \\.+",
                "log": "Backslash character is \\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\.*' token to test matching the character '\\' with capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Backslash character is (\\.*)",
                "log": "Backslash character is \\",
                "end_match": "\\",
                "captured_groups": [
                    "\\"
                ]
            },
            {
                "description": "Using the '\\.*' token to test matching the character '\\' w/o capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Backslash character is \\.*",
                "log": "Backslash character is \\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\t+' token to test NOT matching all the special characters with capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are (\\t+)",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Using the '\\t+' token to test NOT matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are \\t+",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\t*' token to test NOT matching all the special characters with capture group.",
                "pattern": "Special characters are (\\t*)",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Using the '\\t*' token to test NOT matching all the special characters w/o capture group.",
                "pattern": "Special characters are \\t*",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\d+' token to test NOT matching all the special characters with capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are (\\d+)",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Using the '\\d+' token to test NOT matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are \\d+",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\d*' token to test NOT matching all the special characters with capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are (\\d*)",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Using the '\\d*' token to test NOT matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are \\d*",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\D+' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are (\\D+)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<\\"
                ]
            },
            {
                "description": "Using the '\\D+' token to test matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are \\D+",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\D*' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are (\\D*)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<\\"
                ]
            },
            {
                "description": "Using the '\\D*' token to test matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are \\D*",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\w+' token to test NOT matching all the special characters with capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are (\\w+)",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Using the '\\w+' token to test NOT matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are \\w+",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\w*' token to test NOT matching all the special characters with capture group.",
                "pattern": "Special characters are (\\w*)",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Using the '\\w*' token to test NOT matching all the special characters w/o capture group.",
                "pattern": "Special characters are \\w*",
                "log": "Special characters are $()|<\\",
                "end_match": " $()|<\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\W+' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are (\\W+)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<\\"
                ]
            },
            {
                "description": "Using the '\\W+' token to test matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are \\W+",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\W*' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are (\\W*)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<\\"
                ]
            },
            {
                "description": "Using the '\\W*' token to test matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are \\W*",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\S+' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are (\\S+)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<\\"
                ]
            },
            {
                "description": "Using the '\\S+' token to test matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are \\S+",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            },
            {
                "description": "Using the '\\S*' token to test matching all the special characters with capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are (\\S*)",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": [
                    "$()|<\\"
                ]
            },
            {
                "description": "Using the '\\S*' token to test matching all the special characters w/o capture group.",
                "ignore_result": true,
                "__knownIssue": "Link github issue ####",
                "pattern": "Special characters are \\S*",
                "log": "Special characters are $()|<\\",
                "end_match": "\\",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Special characters. '^'",
        "batch_test": [
            {
                "description": "'^' test: Start of string without digits. Dont match",
                "pattern": "^(\\d+)",
                "log": "hi digits",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "'^' test: Match without special caracter",
                "pattern": "\\d+^\\d\\d\\d",
                "ignore_result": false,
                "log": "123^456",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "1234",
                "end_match": "4",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "1234",
                "end_match": "4",
                "captured_groups": [
                    "1234"
                ]
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "1234",
                "end_match": "4",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "1234",
                "end_match": "4",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "1234asd",
                "end_match": "4asd",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "1234asd",
                "end_match": "4asd",
                "captured_groups": [
                    "1234"
                ]
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "1234asd",
                "end_match": "4",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "1234asd",
                "end_match": "4",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Special characters. '$'",
        "batch_test": [
            {
                "description": "'$' test: End of string. Without digits. Dont match",
                "pattern": "(\\d+)$",
                "log": "hi digits",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "'$' test: Match without special caracter",
                "pattern": "\\d+$\\d\\d\\d",
                "log": "123$456",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "'$' test: end of string.",
                "pattern": "(\\d\\d\\d\\d)$",
                "log": "1234",
                "end_match": "4",
                "captured_groups": [
                    "1234"
                ]
            },
            {
                "description": "'$' test: Start of string.",
                "pattern": "(\\d\\d)$",
                "log": "1234",
                "end_match": "4",
                "captured_groups": [
                    "34"
                ]
            },
            {
                "description": "'^' test: Start of string.",
                "pattern": "\\d\\d\\d\\d$",
                "log": "1234",
                "end_match": "4",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "1234",
                "end_match": "4",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "1234asd",
                "end_match": "4asd",
                "captured_groups": []
            },
            {
                "description": "'^' test: Start of string.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "1234asd",
                "end_match": "4asd",
                "captured_groups": [
                    "1234"
                ]
            },
            {
                "description": "'$' test: End of string.",
                "pattern": "\\D\\D$",
                "log": "1234asd",
                "end_match": "d",
                "captured_groups": []
            },
            {
                "description": "'$' test: End of string.",
                "ignore_result": true,
                "pattern": "\\D\\D$",
                "log": "1234asd",
                "end_match": "d",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Combine special characters. ['^', '$']",
        "batch_test": [
            {
                "description": "Combine ^$ with non empty string",
                "pattern": "^$",
                "log": "hi digits",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Combine ^$ with empty string. Should be match",
                "pattern": "^$",
                "log": "",
                "end_match": "",
                "captured_groups": []
            },
            {
                "description": "Combine ^$ with empty string. Should be match, and obtain an empty group",
                "ignore_result": true,
                "pattern": "^()$",
                "log": "",
                "end_match": "",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Combine ^$ with non empty string",
                "pattern": "^$",
                "log": "hi digits",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Combine ^$ with empty string. Should be match",
                "pattern": "^$",
                "log": "",
                "end_match": "",
                "captured_groups": []
            },
            {
                "description": "Combine ^$ with empty string. Should be match, and obtain an empty group",
                "ignore_result": true,
                "pattern": "^()$",
                "log": "",
                "end_match": "",
                "captured_groups": [
                    ""
                ]
            }
        ]
    },
    {
        "description": "[Functionality] Special characters.  OR with flags ['^', '$','|']",
        "batch_test": [
            {
                "description": "Only last subpattern with capture groups",
                "ignore_result": true,
                "pattern": "^$|^\\d|\\d$|\\s(\\w+\\w)",
                "log": "^hi digits asd",
                "end_match": "s asd",
                "captured_groups": [
                    "digits"
                ]
            },
            {
                "description": "Nothing to match",
                "debug": true,
                "pattern": "^$|^\\d|\\d$|\\s(\\w+)",
                "log": "^hi*digits*asd$",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Only last subpattern with last",
                "ignore_result": true,
                "pattern": "^$|^\\d|\\d$|\\.+",
                "log": "^hi digits asd&",
                "end_match": "&",
                "captured_groups": []
            },
            {
                "description": "match with first",
                "pattern": "\\d\\d\\d\\d$|(\\d\\d\\d\\d)$",
                "log": "2020",
                "end_match": "0",
                "captured_groups": []
            }
        ]
    },
    {
        "description": "[Functionality] Corner cases. This tests have shown that OS Regex is not working as expected.",
        "batch_test": [
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "Pattern \\w+ \\d+",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "Pattern (\\w+ \\d+)",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": [
                    "Wazuh 123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "^Pattern \\w+ \\d+",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "^Pattern (\\w+ \\d+)",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": [
                    "Wazuh 123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "Pattern \\w+ \\d+$",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "Pattern (\\w+ \\d+)$",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": [
                    "Wazuh 123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is ' ' (before the '1').",
                "ignore_result": true,
                "pattern": "Pattern \\w* \\d*",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is ' ' (before the '1').",
                "ignore_result": true,
                "pattern": "Pattern (\\w* \\d*)",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": [
                    "Wazuh 123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is ' ' (before the '1').",
                "ignore_result": true,
                "pattern": "^Pattern \\w* \\d*",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is ' ' (before the '1').",
                "ignore_result": true,
                "pattern": "^Pattern (\\w* \\d*)",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": [
                    "Wazuh 123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is ' ' (before the '1').",
                "ignore_result": true,
                "pattern": "Pattern \\w* \\d*$",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is ' ' (before the '1').",
                "ignore_result": true,
                "pattern": "Pattern (\\w* \\d*)$",
                "log": "Pattern Wazuh 123",
                "end_match": "3",
                "captured_groups": [
                    "Wazuh 123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "Subpattern 1: \\d+|Subpattern 2: \\d+",
                "log": "Subpattern 2: 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "Subpattern 1: \\d+|^Subpattern 2: \\d+",
                "log": "Subpattern 2: 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "Subpattern 1: \\d+|Subpattern 2: \\d+$",
                "log": "Subpattern 2: 123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "Subpattern 1: (\\d+)|Subpattern 2: (\\d+)",
                "log": "Subpattern 2: 123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "Subpattern 1: (\\d+)|^Subpattern 2: (\\d+)",
                "log": "Subpattern 2: 123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "Subpattern 1: (\\d+)|Subpattern 2: (\\d+)$",
                "log": "Subpattern 2: 123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is 's' (After '3').",
                "ignore_result": true,
                "pattern": "\\d+",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "\\d+",
                "log": "subpattern123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "\\d+",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '9' but it is '1'.",
                "ignore_result": true,
                "pattern": "\\d+",
                "log": "123456789",
                "end_match": "9",
                "captured_groups": []
            },
            {
                "description": "This case works well.",
                "pattern": "\\d+",
                "log": "1",
                "end_match": "1",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "(\\d+)",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "(\\d+)",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "(\\d+)",
                "log": "subpattern123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '9' but it is '1'.",
                "ignore_result": true,
                "pattern": "(\\d+)",
                "log": "123456789",
                "end_match": "9",
                "captured_groups": [
                    "123456789"
                ]
            },
            {
                "description": "This case works well.",
                "pattern": "(\\d+)",
                "log": "1",
                "end_match": "1",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is 's' (After '3').",
                "ignore_result": true,
                "pattern": "\\d*",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is 's' (After '3').",
                "ignore_result": true,
                "pattern": "\\d*",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": []
            },
            {
                "description": "This test overflows the heap buffer.",
                "skip_test": true,
                "pattern": "\\d*",
                "log": "subpattern123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "(\\d*)",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "With capture group the case works well.",
                "pattern": "(\\d*)",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "This test overflows the heap buffer.",
                "skip_test": true,
                "pattern": "(\\d*)",
                "log": "subpattern123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is 's' (After '3').",
                "ignore_result": true,
                "pattern": "^\\d+",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": []
            },
            {
                "description": "This test passes.",
                "pattern": "^\\d+",
                "log": "subpattern123",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "^(\\d+)",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "This test passes.",
                "pattern": "^(\\d+)",
                "log": "subpattern123",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "^\\d*",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is 's' (After '3').",
                "ignore_result": true,
                "pattern": "^\\d*",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": []
            },
            {
                "description": "This test overflows the heap buffer.",
                "skip_test": true,
                "pattern": "^\\d*",
                "log": "subpattern123",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "^(\\d*)",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "With capture group the case works well.",
                "pattern": "^(\\d*)",
                "log": "123subpattern",
                "end_match": "3subpattern",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "This test overflows the heap buffer.",
                "skip_test": true,
                "pattern": "^(\\d*)",
                "log": "subpattern123",
                "end_match": null,
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "\\d+$",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "\\d+$",
                "log": "log123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "(\\d+)$",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "(\\d+)$",
                "log": "log123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "\\d*$",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "It should match but it doesn't.",
                "ignore_result": true,
                "pattern": "\\d*$",
                "log": "pattern123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "This test passes.",
                "pattern": "\\d*$",
                "log": "123pattern",
                "end_match": null,
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "(\\d*)$",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "It should match but it doesn't.",
                "ignore_result": true,
                "pattern": "(\\d*)$",
                "log": "pattern123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "This test passes.",
                "pattern": "(\\d*)$",
                "log": "123pattern",
                "end_match": null,
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Consecutive capture groups (without something in between) do not match when should.",
                "ignore_result": true,
                "pattern": "(\\D+)(\\d+)",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": [
                    "Test",
                    "123"
                ]
            },
            {
                "description": "Consecutive capture groups (without something in between) do not match.",
                "ignore_result": true,
                "pattern": "(\\d+)(\\D+)",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "123",
                    "Test"
                ]
            },
            {
                "description": "Consecutive capture groups (without something in between) do not match.",
                "ignore_result": true,
                "pattern": "(\\D*)(\\d*)",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": [
                    "Test",
                    "123"
                ]
            },
            {
                "description": "Consecutive capture groups (without something in between) do not match.",
                "ignore_result": true,
                "pattern": "(\\d*)(\\D*)",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "123",
                    "Test"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is '1'.",
                "ignore_result": true,
                "pattern": "\\D+\\d+",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is 'T'.",
                "ignore_result": true,
                "pattern": "\\d+\\D+",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be '3' but it is 't'.",
                "ignore_result": true,
                "pattern": "\\D*\\d*",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '3'.",
                "ignore_result": true,
                "pattern": "\\d*\\D*",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "When there are 4 more optional tokens than characters to match, the regex doesn't match.",
                "ignore_result": true,
                "pattern": "\\w*\\w*\\w*\\w*\\w*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with extra optional tokens inside a capture group, it does match.",
                "pattern": "(\\w*\\d*\\w*\\d*\\w*\\d*)",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with extra optional tokens inside a capture group, it does match.",
                "pattern": "^(\\w*\\d*\\w*\\d*\\w*\\d*)",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with extra optional tokens inside a capture group, it does match.",
                "pattern": "(\\w*\\d*\\w*\\d*\\w*\\d*)$",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with 10 extra optional tokens inside a capture group, it does match.",
                "pattern": "(\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*)",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with 10 extra optional tokens inside a capture group, it does match.",
                "pattern": "^(\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*)",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with 10 extra optional tokens inside a capture group, it does match.",
                "pattern": "(\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*\\w*)$",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with 3 extra optional tokens, it does NOT match.",
                "ignore_result": true,
                "pattern": "\\w*\\p*\\d*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with 3 extra optional tokens, it does NOT match.",
                "ignore_result": true,
                "pattern": "^\\w*\\p*\\d*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with 3 extra optional tokens, it does NOT match.",
                "ignore_result": true,
                "pattern": "\\w*\\p*\\d*\\w*$",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with 3 extra optional tokens inside a capture group, it does match.",
                "pattern": "(\\w*\\p*\\d*\\w*)",
                "log": "xy",
                "end_match": "y",
                "captured_groups": [
                    "xy"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with 3 extra optional tokens, it does NOT match.",
                "ignore_result": true,
                "pattern": "\\w*\\d*\\w*\\p*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with 2 extra optional tokens, it does match.",
                "pattern": "\\w*\\d*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with 2 extra optional tokens, it does match.",
                "pattern": "^\\w*\\d*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with 2 extra optional tokens, it does match.",
                "pattern": "\\w*\\d*\\w*$",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with 3 extra optional tokens, it does NOT match.",
                "ignore_result": true,
                "pattern": "\\w*\\d*\\p*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case, with only 3 extra optional tokens, it does match.",
                "pattern": "\\w*\\w*\\w*\\w*\\w*",
                "log": "xy",
                "end_match": "y",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case there are 2 exceding optional tokens, the regex doesn't match.",
                "ignore_result": true,
                "pattern": "xyz\\d*\\w*",
                "log": "xyz",
                "end_match": "z",
                "captured_groups": []
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case there are 2 exceding optional tokens inside a capture groupe, the regex doesn't match.",
                "ignore_result": true,
                "pattern": "xyz(\\d*\\w*)",
                "log": "xyz",
                "end_match": "z",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case there is 1 exceding optional token inside a capture groupe, the regex does match but the expected group is not captured.",
                "ignore_result": true,
                "pattern": "xyz(\\w*)",
                "log": "xyz",
                "end_match": "z",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case there are 2 exceding optional tokens inside a capture groupe, the regex doesn't match.",
                "pattern": "xyz(\\w*)",
                "log": "xyz ",
                "end_match": "z ",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case there are 2 exceding optional tokens inside a capture groupe, the regex doesn't match.",
                "ignore_result": true,
                "pattern": "xyz\\w*(\\w*)",
                "log": "xyz",
                "end_match": "z",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case the regex does match.",
                "pattern": "(xyz\\w*\\w*)",
                "log": "xyz",
                "end_match": "z",
                "captured_groups": [
                    "xyz"
                ]
            },
            {
                "description": "Tokens with optional quantifier (*) should always match, but they don't.",
                "__knownIssue:": "In this case the regex does match.",
                "pattern": "\\d+\\w*\\w*",
                "log": "123",
                "end_match": "3",
                "captured_groups": []
            },
            {
                "description": "Capture group is not correctly obtained. It should be '123' but it is empty.",
                "ignore_result": true,
                "pattern": "(\\d+)\\D*",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "This case matches.",
                "pattern": "(\\d+)\\D* ",
                "log": "123 ",
                "end_match": " ",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '3'.",
                "ignore_result": true,
                "pattern": "(\\d+)\\D*",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be '123' but it is empty.",
                "ignore_result": true,
                "pattern": "(\\d+)\\D*",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "ignore_result": true,
                "pattern": "\\d+(\\D*)",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '3'.",
                "ignore_result": true,
                "pattern": "\\d+(\\D*)",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "Test"
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "ignore_result": true,
                "pattern": "\\d+(\\D*)",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "ignore_result": true,
                "pattern": "^\\d+(\\D*)",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '3'.",
                "ignore_result": true,
                "pattern": "^\\d+(\\D*)",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "Test"
                ]
            },
            {
                "description": "This test passes.",
                "pattern": "^\\d+(\\D*)",
                "log": "Test123",
                "end_match": null,
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "ignore_result": true,
                "pattern": "^(\\d+)\\D*",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '3'.",
                "ignore_result": true,
                "pattern": "^(\\d+)\\D*",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "This test passes.",
                "pattern": "^(\\d+)\\D*",
                "log": "Test123",
                "end_match": null,
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "ignore_result": true,
                "pattern": "\\d+(\\D*)$",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Last matched character pointed (end_match) should be 't' but it is '3'.",
                "ignore_result": true,
                "pattern": "\\d+(\\D*)$",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "Test"
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "ignore_result": true,
                "pattern": "\\d+(\\D*)$",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": [
                    ""
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "ignore_result": true,
                "pattern": "(\\d+)\\D*$",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "ignore_result": true,
                "pattern": "(\\d+)\\D*$",
                "log": "123Test",
                "end_match": "t",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Capture group is not correctly obtained. It should be an empty group but it is null.",
                "ignore_result": true,
                "pattern": "(\\d+)\\D*$",
                "log": "Test123",
                "end_match": "3",
                "captured_groups": [
                    "123"
                ]
            },
            {
                "description": "Capture group is not correctly obtained.",
                "ignore_result": true,
                "pattern": "(\\d*)\\w*",
                "log": "123",
                "end_match": "3",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Capture group is not correctly obtained.",
                "ignore_result": true,
                "pattern": "(\\d*)\\w*",
                "log": "123Test",
                "end_match": "3",
                "captured_groups": [
                    "1"
                ]
            },
            {
                "description": "Regex should match but does not.",
                "__knownIssue": "Only 4 'recoverage' levels are allowed.",
                "ignore_result": true,
                "pattern": "(\\w+1) (\\w+2) (\\w+3) (\\w+4) (\\w+5)",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5xyz5",
                "end_match": "5",
                "captured_groups": [
                    "xyz1xyz1",
                    "xyz2xyz2",
                    "xyz3xyz3",
                    "xyz4xyz4",
                    "xyz5xyz5"
                ]
            },
            {
                "description": "This case matches.",
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5xyz5",
                "end_match": "5xyz5",
                "captured_groups": []
            },
            {
                "description": "This case matches.",
                "ignore_result": true,
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5$",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5xyz5",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "This case matches.",
                "pattern": "(\\w+1) (\\w+2) (\\w+3) (\\w+4) (\\w+5)",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5",
                "end_match": "5",
                "captured_groups": [
                    "xyz1xyz1",
                    "xyz2xyz2",
                    "xyz3xyz3",
                    "xyz4xyz4",
                    "xyz5"
                ]
            },
            {
                "description": "Regex should match but does not.",
                "ignore_result": true,
                "pattern": "(\\w+1) (\\w+2) (\\w+3) (\\w+4) (\\w+5) (\\w+6)$",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5 xyz6xyz6",
                "end_match": "6",
                "captured_groups": [
                    "xyz1xyz1",
                    "xyz2xyz2",
                    "xyz3xyz3",
                    "xyz4xyz4",
                    "xyz5",
                    "xyz6xyz6"
                ]
            },
            {
                "description": "Regex should match but does not.",
                "ignore_result": true,
                "pattern": "\\w+1 \\w+2 \\w+3 \\w+4 \\w+5 \\w+6$",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5 xyz6xyz6",
                "end_match": "6",
                "captured_groups": []
            },
            {
                "description": "This case matches.",
                "pattern": "(\\w+1) (\\w+2) (\\w+3) (\\w+4) (\\w+5) (\\w+6)$",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5 xyz6",
                "end_match": "6",
                "captured_groups": [
                    "xyz1xyz1",
                    "xyz2xyz2",
                    "xyz3xyz3",
                    "xyz4xyz4",
                    "xyz5",
                    "xyz6"
                ]
            },
            {
                "description": "Regex should match but does not.",
                "ignore_result": true,
                "pattern": "(\\w+1) (\\w+2) (\\w+3) (\\w+4) (\\w+5) (\\w+6)$",
                "log": "xyz1xyz1 xyz2xyz2 xyz3xyz3 xyz4xyz4 xyz5xyz5 xyz6",
                "end_match": "6",
                "captured_groups": [
                    "xyz1xyz1",
                    "xyz2xyz2",
                    "xyz3xyz3",
                    "xyz4xyz4",
                    "xyz5xyz5",
                    "xyz6"
                ]
            },
            {
                "description": "This case has 3 (non-optional) tokens but it is capturing only 2 characters.",
                "__knownIssue": "Capture groups could be either '04T15' or '4T15', depending on the (unpredictable) behavior of the greediness.",
                "ignore_result": true,
                "pattern": "(\\d+\\w\\d+)",
                "log": "04T15",
                "end_match": "5",
                "captured_groups": [
                    "04T15"
                ]
            },
            {
                "description": "This case should match but it does not.",
                "ignore_result": true,
                "pattern": "(-\\d+\\w\\d+:)",
                "log": "-04T15:",
                "end_match": ":",
                "captured_groups": [
                    "-04T15:"
                ]
            },
            {
                "description": "This case should match but it does not.",
                "ignore_result": true,
                "pattern": "-(\\d+\\w\\d+):",
                "log": "-04T15:",
                "end_match": ":",
                "captured_groups": [
                    "04T15"
                ]
            },
            {
                "description": "This case should match but it does not.",
                "ignore_result": true,
                "pattern": "-\\d+\\w\\d+:",
                "log": "-04T15:",
                "end_match": ":",
                "captured_groups": []
            },
            {
                "description": "This case matches.",
                "__knownIssue": "Wrong end_match value.",
                "ignore_result": true,
                "pattern": "\\d+\\w\\d+",
                "log": "04T15",
                "end_match": "5",
                "captured_groups": []
            },
            {
                "description": "This case matches.",
                "__knownIssue": "Wrong end_match value.",
                "ignore_result": true,
                "pattern": "(\\d+\\D\\d+)",
                "log": "04T15",
                "end_match": "5",
                "captured_groups": [
                    "04T15"
                ]
            },
            {
                "description": "This case matches.",
                "pattern": "(-\\d+\\D\\d+:)",
                "log": "-04T15:",
                "end_match": ":",
                "captured_groups": [
                    "-04T15:"
                ]
            },
            {
                "description": "This case matches.",
                "pattern": "-(\\d+\\D\\d+):",
                "log": "-04T15:",
                "end_match": ":",
                "captured_groups": [
                    "04T15"
                ]
            },
            {
                "description": "This case matches.",
                "pattern": "-\\d+\\D\\d+:",
                "log": "-04T15:",
                "end_match": ":",
                "captured_groups": []
            },
            {
                "description": "This case matches.",
                "__knownIssue": "Wrong end_match value.",
                "ignore_result": true,
                "pattern": "\\d+\\D\\d+",
                "log": "04T15",
                "end_match": "5",
                "captured_groups": []
            }
        ]
    }
]